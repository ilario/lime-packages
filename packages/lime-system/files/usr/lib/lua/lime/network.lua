#!/usr/bin/lua

network = {}

local bit = require "nixio".bit
local ip = require "luci.ip"
local config = require "lime.config"
local utils = require "lime.utils"

network.limeIfNamePrefix="lm_"
network.protoParamsSeparator=":"
network.vlanSeparator="."

function network.get_mac(ifname)
	local mac = assert(fs.readfile("/sys/class/net/"..ifname.."/address")):gsub("\n","")
	return utils.split(mac, ":")
end

function network.primary_interface()
	return config.get("network", "primary_interface")
end

function network.primary_mac()
	return network.get_mac(network.primary_interface())
end

function network.primary_address()
	local ipv4_template = config.get("network", "main_ipv4_address")
	local ipv6_template = config.get("network", "main_ipv6_address")
	local pm = network.primary_mac()
	
	for i=1,6,1 do
		ipv4_template = ipv4_template:gsub("M" .. i, tonumber(pm[i], 16))
		ipv6_template = ipv6_template:gsub("M" .. i, pm[i])
	end

	return ip.IPv4(ipv4_template), ip.IPv6(ipv6_template) 
end

function network.generate_host(ipprefix, hexsuffix)
    -- use only the 8 rightmost nibbles for IPv4, or 32 nibbles for IPv6
    hexsuffix = hexsuffix:sub((ipprefix[1] == 4) and -8 or -32)

    -- convert hexsuffix into a cidr instance, using same prefix and family of ipprefix
    local ipsuffix = ip.Hex(hexsuffix, ipprefix:prefix(), ipprefix[1])

    local ipaddress = ipprefix
    -- if it's a network prefix, fill in host bits with ipsuffix
    if ipprefix:equal(ipprefix:network()) then
        for i in ipairs(ipprefix[2]) do
            -- reset ipsuffix netmask bits to 0
            ipsuffix[2][i] = bit.bxor(ipsuffix[2][i],ipsuffix:network()[2][i])
            -- fill in ipaddress host part, with ipsuffix bits
            ipaddress[2][i] = bit.bor(ipaddress[2][i],ipsuffix[2][i])
        end
    end

    return ipaddress
end

function network.generate_address(p, n)
    local id = n
    local m4, m5, m6 = node_id()
    local n1, n2, n3 = network_id()
    local ipv4_template = config.get("network", "main_ipv4_address")
    local ipv6_template = config.get("network", "main_ipv6_address")

    ipv6_template = ipv6_template:gsub("N1", hex(n1)):gsub("N2", hex(n2)):gsub("N3", hex(n3))
    ipv4_template = ipv4_template:gsub("N1", n1):gsub("N2", n2):gsub("N3", n3)

    hexsuffix = hex((m4 * 256*256 + m5 * 256 + m6) + id)
    return network.generate_host(ip.IPv4(ipv4_template), hexsuffix),
           network.generate_host(ip.IPv6(ipv6_template), hexsuffix)
end

function network.eui64(mac)
    local function flip_7th_bit(x) return utils.hex(bit.bxor(tonumber(x, 16), 2)) end

    local t = utils.split(mac, ":")
    t[1] = flip_7th_bit(t[1])

    return string.format("%s%s:%sff:fe%s:%s%s", t[1], t[2], t[3], t[4], t[5], t[6])
end

function network.setup_rp_filter()
	local sysctl_file_path = "/etc/sysctl.conf";
	local sysctl_options = "";
	local sysctl_file = io.open(sysctl_file_path, "r");
	while sysctl_file:read(0) do
		local sysctl_line = sysctl_file:read();
		if not string.find(sysctl_line, ".rp_filter") then sysctl_options = sysctl_options .. sysctl_line .. "\n" end 
	end
	sysctl_file:close()
	
	sysctl_options = sysctl_options .. "net.ipv4.conf.default.rp_filter=2\nnet.ipv4.conf.all.rp_filter=2\n";
	sysctl_file = io.open(sysctl_file_path, "w");
	sysctl_file:write(sysctl_options);
	sysctl_file:close();
end

function network.clean()
	print("Clearing network config...")

	uci:delete("network", "globals", "ula_prefix")

	-- Delete interfaces generated by LiMe
	uci:foreach("network", "interface", function(s) if s[".name"]:match(network.limeIfNamePrefix) then uci:delete("network", s[".name"]) end end)
end

function network.scandevices()
	local devices = {}

	-- Scan for plain ethernet interfaces
	for _,dev in pairs(utils.split(io.popen("ls -1 /sys/class/net/"):read("*a"), "\n")) do
		if dev:match("^eth%d$") then
			table.insert(devices, dev)
		end
	end

	-- Scan for plain wireless interfaces
	uci:foreach("wireless", "wifi-iface", function(s) table.insert(devices, s["ifname"]) end)

	-- When we will support other device type just scan for them here
	
	return devices
end

function network.configure()

	network.clean()
	network.setup_rp_filter()

	local generalProtocols = config.get("network", "protocols")
	for _,protocol in pairs(generalProtocols) do
		local proto = require("lime.proto."..utils.split(protocol,":")[1])
		proto.configure()
	end

	local specificIfaces = {}
	config.foreach("net", function(iface) specificIfaces[iface[".name"]] = iface end)
	
	-- Scan for fisical devices, if there is a specific config apply that otherwise apply general config
	local fisDevs = network.scandevices()
	for _,device in pairs(fisDevs) do
		local owrtIf = specificIfaces[device]
		if owrtIf then
			for _,protoParams in pairs(owrtIf["protocols"]) do
				local args = utils.split(protoParams, network.protoParamsSeparator)
				if args[1] == "manual" then break end -- If manual is specified do not configure interface
				local proto = require("lime.proto."..args[1])
				proto.setup_interface(device, args)
			end
		else
			for _,protoParams in pairs(generalProtocols) do
				local args = utils.split(protoParams, network.protoParamsSeparator)
				local proto = require("lime.proto."..args[1])
				proto.setup_interface(device, args)
			end
		end
	end
end

return network
